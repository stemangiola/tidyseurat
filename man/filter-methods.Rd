% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr_methods.R
\name{filter}
\alias{filter}
\title{Subset rows using column values}
\arguments{
\item{...}{<[`tidy-eval`][dplyr_eval]> Logical predicates defined in
terms of the variables in `.data`.
Multiple conditions are combined with `&`. Only rows where the
condition evaluates to `TRUE` are kept.}

\item{.preserve}{when `FALSE` (the default), the grouping structure
is recalculated based on the resulting data, otherwise it is kept as is.}
}
\value{
An object of the same type as `.data`.

* Rows are a subset of the input, but appear in the same order.
* Columns are not modified.
* The number of groups may be reduced (if `.preserve` is not `TRUE`).
* Data frame attributes are preserved.
}
\description{
`filter()` retains the rows where the conditions you provide a `TRUE`. Note
that, unlike base subsetting with `[`, rows where the condition evaluates
to `NA` are dropped.
}
\details{
dplyr is not yet smart enough to optimise filtering optimisation
on grouped datasets that don't need grouped calculations. For this reason,
filtering is often considerably faster on ungroup()ed data.
}
\examples{

data("pbmc_small")
pbmc_small |> filter(groups == "g1")

# Learn more in ?dplyr_eval
}
\seealso{
Other single table verbs: 
\code{\link{arrange}()}
}
\concept{single table verbs}
